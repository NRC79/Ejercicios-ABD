---
title: "Tema 3: Ejercicios"
format:
  html:
    code-copy:       true
    code-tools:      true
    embed-resources: true
    theme:           ../www/extra-styles.scss
    toc:             true
    toc-location:    left
callout-appearance: minimal
---

# Introducci√≥n

En este hemos visto los fundamentos del modelado Bayesiano, y vamos a aplicarlos desde un punto de vista te√≥rico en los ejercicios a continuaci√≥n.

En primer lugar, configuramos el entorno para ejecutar el c√≥digo.

```{r setup}
#| message: false

# Paquetes:
library(tidyverse)
library(RColorBrewer)


# Configuraci√≥n de la salida gr√°fica:

PALETA <- brewer.pal(8, "Set2") # Colores por defecto
color_defecto  <- PALETA[1]
options(ggplot2.discrete.colour = PALETA)

theme_set(theme_bw()) # Tema "neutro" para la representaci√≥n gr√°fica
```

Ver√°s que solamente necesitamos el paquete {tidyverse}, para manipular datos, y configurar la salida gr√°fica (el paquete {RColorBrewer} s√≥lo se utiliza para obtener una paleta de colores agradable y accesible para personas con ceguera al color).
No hace falta ning√∫n paquete para an√°lisis y modelado Bayesiano, ya que los modelos que vamos a estimar se basan en las propiedades anal√≠ticas de las *distribuciones conjugadas*.

# Ejercicio 1

## Distribuci√≥n uniforme

A continuaci√≥n se muestra el c√≥digo en R para representar la distribuci√≥n uniforme $x \sim U(0, 1)$:

```{r ejemplo-uniforme}
PREC     <- 1e-3 # Precisi√≥n para representar la funci√≥n de densidad (mil√©simas)
DENS_INF <- 0    # Rango inferior de la funci√≥n de densidad
DENS_SUP <- 1    # Rango superior de la funci√≥n de densidad

uniforme <- tibble( # Esta funci√≥n crea un "data.frame" o tabla de datos
  variable = seq(from = DENS_INF, to = DENS_SUP, by = PREC),
  densidad = variable |> dunif(min = DENS_INF, max = DENS_SUP)
)

uniforme |> glimpse() # Muestra el objeto con los datos, contiene 2 columnas 

uniforme |> # Usando la tabla de datos antes creada, crea un objeto gr√°fico
  ggplot(mapping = aes(x = variable, y = densidad)) + # "Mapea" columnas a
                                                      #   coordenadas
  geom_line(color = color_defecto) + # Representa mediante una l√≠nea continua
  
  ylim( # Fija el l√≠mite inferior a 0 para mostrar el eje y completo:
    0,  # (Usa la propia distribuci√≥n para establecer el l√≠mite superior)
    uniforme |> pull(densidad) |> max()
  )
```

## Distribuci√≥n normal

Aplicando un c√≥digo similar, se puede representar una distribuci√≥n normal estandarizada $x \sim N(0, 1)$:

```{r ejemplo-normal}
DENS_INF <- -4 # Usamos un rango m√°s adecuado para la normal estandarizada
DENS_SUP <-  4

normal <- tibble( # Reutilizamos `PREC` del "chunk" de c√≥digo anterior
  variable = seq(from = DENS_INF, to = DENS_SUP, by = PREC),
  densidad = variable |> dnorm()
)

# Al cubrir la distribuci√≥n el rango desde 0 hasta el m√°ximo, en este caso no
#   es necesario establecer los l√≠mites manualmente
normal |>
  ggplot(mapping = aes(x = variable, y = densidad)) +
  geom_line(color = color_defecto)
```

Como puedes ver, los l√≠mites se establecen autom√°ticamente para cubrir todo el rango de la distribuci√≥n (no hace falta fijarlos).
Al haber valores pr√≥ximos a 0, tampoco es necesario establecer el l√≠mite inferior manualmente.

## Integraci√≥n "num√©rica"

Haciendo uso de los valores generados de una distribuci√≥n, podemos operar con ellos para obtener los resultados de "integrar" esa funci√≥n, pero haci√©ndolo de forma num√©rica.

Al obtener "valores equiespaciados" de la distribuci√≥n, lo que estamos obteniendo es una "rejilla" de valores.
La integraci√≥n ser√° una suma de "rect√°ngulos", de altura igual a la densidad en ese punto, con base centrada en ese punto y extenci√©ndose `PREC/2` hacia cada lado (y por tanto de anchura `PREC`).

Utilizando esta "integral num√©rica", podemos obtener ciertos valores de la distribuci√≥n.
Por ejemplo, la integral en todo el dominio de la variable deber√≠a tener un valor de 1.

```{r integral-uniforme}
uniforme |> summarize(integral = PREC * sum(densidad))
```

En el caso de la distribuci√≥n uniforme, tenemos valores "centrados" en 0 y 1, por lo que los intervalos de los extremos se extienden hasta `-PREC/2` y `1 + PREC/2`.
Podr√≠amos "restar medio valor" de la densidad en cada extremo para obtener una integral m√°s precisa:

```{r}
uniforme |> summarize(
  integral = PREC * (sum(densidad) - 0.5 * (first(densidad) + last(densidad)))
)
```

En el caso de la distribuci√≥n normal el c√°lculo de la integral se har√≠a igual:

```{r integral-normal}
normal |> summarize(
  integral = sum(densidad) * PREC
)
```

En este caso, el dominio es infinito, pero nos hemos restringido al rango $[`{r} DENS_INF`, `{r} DENS_SUP`]$.
Por lo tanto, estamos desechando la parte de la distribuci√≥n que est√° en las "colas".
Tambi√©n, cuanto mayor sea la precisi√≥n, m√°s se acercar√° la aproximaci√≥n mediante "rect√°ngulos" a la curva real.

```{r integral-normal-mas-precisa}
tibble( # Ampliando el rango a [-10, 10]:
  variable = seq(from = -10, to = 10, by = PREC),
  densidad = variable |> dnorm()
) |>
  summarize(integral = sum(densidad) * PREC)

tibble( # Usando precisi√≥n de "millon√©simas":
  variable = seq(from = DENS_INF, to = DENS_SUP, by = 1e-6),
  densidad = variable |> dnorm()
) |>
  summarize(integral = sum(densidad) * 1e-6) # Misma precisi√≥n en la integral
```

En general, las aproximaciones iniciales pueden ser v√°lidas.
Si lo necesitamos, podemos "normalizar" por la integral.
Los siguiente ejemplos, triviales, pueden ayudarnos m√°s adelante:

```{r integral-normalizada}
uniforme |> summarize(
  integral = PREC * sum(densidad),
  integral = integral / integral # Normalizaci√≥n
)

normal |> summarize(
  integral = PREC * sum(densidad),
  integral = integral / integral # Normalizaci√≥n
)
```

## Pr√°ctica

Calcula o comprueba las siguientes respuestas usando comandos de R:

### Pregunta 1

-   ¬øCu√°l es el valor m√°ximo de la funci√≥n de densidad?

::: {#respuesta-1 .callout-note}
```{r normal-estandarizada}
x <- seq(-4, 4) # rango de valores para evaluar
pdf_values <- dnorm(x) # valores de la PDF
max_pdf <- max(pdf_values) # valor m√°ximo de la PDF
max_pdf
```
```{r uniforme}
a <- 0  # L√≠mite inferior
b <- 1  # L√≠mite superior

max_pdf <- 1 / (b - a) # Valor m√°ximo
max_pdf
```
:::

### Pregunta 2

-   ¬øPara qu√© valor de la variable aleatoria se da? ¬øC√≥mo llamar√≠as a ese valor?

::: {#respuesta-2 .callout-note}
 Este m√°ximo se dar√° en la media, en el caso de la distribuci√≥n normal estandarizada el valor x=0
 
 En una distribuci√≥n uniforme todos los valores dentro del intervalo presentan la misma densidad
:::

### Pregunta 3

-   El valor m√°ximo, ¬øpuede ser mayor que 1? Justifica tu respuesta.

::: {#respuesta-3 .callout-note}
En t√©rminos generales no, pues el valor del √°rea que queda por debajo de curva siempre debe ser 1. No obstante, en una funci√≥n uniforme con un intervalo mayor que 0 y menor que 1 se pueden obtener valores m√°ximos superiores a 1.  
:::

### Pregunta 4

-   Calcula y representa la funci√≥n de distribuci√≥n de la variable normal

*(Ejecuta `?cumsum` para consultar la ayuda de esa funci√≥n).*

::: {#respuesta-4 .callout-note}
```{r funci√≥n distribuci√≥n variable normal}
x <- seq(-4, 4)

# Calcular la funci√≥n de distribuci√≥n acumulativa
cdf_values <- pnorm(x)

# Representaci√≥n gr√°fica de la CDF
plot(x, cdf_values, type = "l", col = "red", lwd = 2,
     xlab = "Valores de la variable",
     ylab = "Probabilidad acumulada",
     main = "Distribuci√≥n acumulativa (CDF) de una normal est√°ndar")
```

:::

### Pregunta 5

-   Calcula el valor esperado de la distribuci√≥n normal.

::: {#respuesta-5 .callout-note}
El valor esperado de la distribuci√≥nnormal es la media.
:::

# Ejercicio 2

## Distribuci√≥n Beta

### Pregunta 6

-   Representa una distribuci√≥n Beta con par√°metros $\alpha$ = $\beta$ = 1, $Beta(1, 1)$. Ajusta los ejes correctamente, si hace falta, como en la distribuci√≥n uniforme.

*(Si no sabes qu√© limites utilizar, consulta la ayuda de `dbeta()`).*

::: {#respuesta-6 .callout-note}
```{r distribuci√≥n Beta}
x <- seq(0, 1)# Definir rango valores para x

pdf_values <- dbeta(x, shape1 = 1, shape2 = 1)#densidad distribuci√≥n Beta(1, 1)

# Representar la distribuci√≥n Beta(1, 1)
plot(x, pdf_values, type = "l", col = "blue", lwd = 2,
     xlab = "Valores de x", ylab = "Densidad",
     main = "Funci√≥n de densidad de Beta(1, 1)",
     ylim = c(0, 1)) 

```

:::

### Pregunta 7

-   ¬øQu√© forma tiene?

::: {#respuesta-7 .callout-note}
Tiene una forma de l√≠nea recta con un valor de densidad uniforme para todo el intervalo.
:::

## Par√°metros de la distribuci√≥n Beta

### Pregunta 8

-   Prueba con diferentes valores de $\alpha$ y $\beta$.

::: {#respuesta-8 .callout-note}
```{r distribuci√≥n beta distintos valores}
x <- seq(0, 1, length = 1000)

# Calcular y graficar varias distribuciones Beta
plot(x, dbeta(x, shape1 = 2, shape2 = 4), type = "l", col = "red", lwd = 2,
     xlab = "Valores de x", ylab = "Densidad",
     main = "Distribuciones Beta con diferentes par√°metros")
lines(x, dbeta(x, shape1 = 4, shape2 = 2), col = "blue", lwd = 2) # Beta(4, 2)
lines(x, dbeta(x, shape1 = 1.1, shape2 = 1.1), col = "green", lwd = 2) # Beta(1.1, 1.1)
lines(x, dbeta(x, shape1 = 0.5, shape2 = 0.5), col = "yellow", lwd = 2) # Beta(0.5, 0.5)
lines(x, dbeta(x, shape1 = 4, shape2 = 4), col = "black", lwd = 2)# Beta(4, 4)
```

:::

### Pregunta 9

-   ¬øQu√© ocurre a medida que van creciendo?

::: {#respuesta-9 .callout-note}
Si son iguales, a medida que crecen la distribuci√≥n va adquiriendo forma de campana y cuanto m√°s crecen la campana se va haciendo m√°s estrecha.Cuando aumenta beta los valores se concentran m√°s pr√≥ximos a x = 0, mientras que seg√∫n crece alfa los valores se concentran m√°s pr√≥ximos a x = 1
:::

### Pregunta 10

-   ¬øQu√© ocurre cuando son iguales? ¬øY cu√°ndo son distintos?

::: {#respuesta-10 .callout-note}
Cuando son iguales la distribuci√≥n es sim√©trica y cuando son distintos las distribuciones son m√°s asim√©tricas, tanto m√°s cuanto mayor sea la diferencia de magnitud entre los par√©metros.
:::

### Pregunta 11

-   ¬øQu√© ocurre si tienen valores ligeramente superiores a 1?

::: {#respuesta-11 .callout-note}
Con valores ligeramente superiores a 1 la distribuci√≥n crece r√°pidamente desde x = 0 alcanzando casi la densidad m√°xima. Esta se alcanzaenx = 0,5 (si ambos alpha y beta son iguales). Lo diferencial es que en este caso ya no estamos ante una distribuci√≥n uniforme.
:::

### Pregunta 12

-   ¬øQu√© ocurre si tienen valores por debajo de 1?

::: {#respuesta-12 .callout-note}
La funci√≥n adquiere forma de U, d√°ndose la mayor densidad en los valores extremos de x. Los valores medios de x en este caso tienen una probabilidad menor.
:::

# Ejercicio 3

*(NOTA: Para todas las distribuciones, utiliza el valor de `PREC` definido en el ejercicio 1.)*

## Modelo beta-binomial

En el departamento de investigaci√≥n de mercado de tu empresa quieren saber la tasa de aceptaci√≥n de la nueva app que quieren lanzar.
Para ello, han probado la app con una muestra (asume m.a.s.) de $n$ potenciales usuarios/as, y se las pedido que indiquen si descargar√≠an o no la app.

El jefe del departamento de anal√≠tica te asigna al proyecto y te pide que ajustes un modelo beta-binomial "no informativo" para responder a la pregunta de investigaci√≥n.

### Pregunta 13

-   ¬øC√≥mo se representa la "tasa de aceptaci√≥n" en el modelo?

::: {#respuesta-13 .callout-note}
Se representa con una distribuci√≥n binomial condicionada a theta
$ùëã‚à£ùúÉ‚àºBinomial(ùëõ,ùúÉ)$

:::

### Pregunta 14

-   ¬øQu√© distribuci√≥n previa utilizar√≠as para esa tasa de aceptaci√≥n? Form√∫lala y repres√©ntala gr√°ficamente.

*(Ajusta los ejes correctamente, si hace falta, como en la distribuci√≥n uniforme).*

::: {#respuesta-14 .callout-note}
COmo distribuci√≥n previa, emplear√≠a una distribuci√≥n Beta (1,1), puesto que al ser uniforme no es informativa. Lo √∫nico que nos dice es que en el intervalo dado, todos los valores tienen la misma probabilidad.
$ùúÉ‚àº Beta(1,1)$
```{r distribucion Beta}
alpha <- 1
beta <- 1
theta <- seq(0, 1)
density <- dbeta(theta, alpha, beta)
plot(theta, density, type = "l", col = "blue", lwd = 2,
     main = "Distribuci√≥n Previa Beta(1, 1)",
     xlab = "Tasa de aceptaci√≥n (Œ∏)", ylab = "Densidad",
     ylim = c(0, 1))  
abline(h = 1, col = "red", lty = 2)

```

:::

### Pregunta 15

-   Sup√≥n que $y$ es el n√∫mero de usuarios/as que han respondido que "S√≠" descargar√≠an la app. Formula la verosimilitud del modelo.

::: {#respuesta-15 .callout-note}
$P(y \mid n, p) = \binom{n}{y} p^y (1-p)^{n-y}$
:::

## Ajuste del modelo

-   El departamento de investigaci√≥n de mercado te da acceso a los siguientes datos de la muestra:

```{r beta-binomial-muestra}
aceptacion_muestra <- tibble(
  id_participante   = 1:22,
  resp_descarga_app = c(
    "Si", "Si", "No", "No", "Si", "Si", "Si", "Si", "No", "Si", "Si",
    "Si", "Si", "Si", "Si", "Si", "No", "Si", "No", "Si", "Si", "Si"
  )
)
```

### Pregunta 16

-   Obt√©n, en base a estos datos, la distribuci√≥n posterior de la tasa de aceptaci√≥n (en forma anal√≠tica), y repres√©ntala junto a la distribuci√≥n previa.

::: {#respuesta-16 .callout-note}
```{r distribuci√≥n posterior tasa aceptaci√≥n}
# Calcular n (tama√±o de la muestra) y y (n√∫mero de "S√≠")
n <- nrow(aceptacion_muestra)
y <- sum(aceptacion_muestra$resp_descarga_app == "Si")

# Par√°metros del prior Beta(1, 1)
a <- 1
b <- 1
# Posterior Beta(a + y, b + n - y)
a_post <- a + y
b_post <- b + (n - y)

# Resultados
cat("Tama√±o de la muestra (n):", n, "\n")
cat("N√∫mero de √©xitos (y):", y, "\n")
cat("Posterior Beta(", a_post, ",", b_post, ")\n")

# Graficar la distribuci√≥n posterior
p <- seq(0, 1, length.out = 1000)  # Valores de la tasa de aceptaci√≥n
densidad <- dbeta(p, a_post, b_post)  # Densidad de la posterior

# Graficar usando ggplot2
library(ggplot2)
ggplot(data = data.frame(p, densidad), aes(x = p, y = densidad)) +
  geom_line(color = "blue", size = 1) +
  labs(title = paste("Distribuci√≥n Posterior Beta(", a_post, ",", b_post, ")"),
       x = "Tasa de aceptaci√≥n (p)",
       y = "Densidad de probabilidad") +
  theme_minimal()
```

:::

### Pregunta 17

-   Obt√©n el valor esperado y la moda de la distribui√≥n posterior. ¬øC√≥mo los interpretar√≠as?

*(Nota: Ten en cuenta la "precisi√≥n" al calcular el "peso" de cada muestra.)*

::: {#respuesta-17 .callout-note}
```{r valor esperado y moda}
# Calcular los valores esperados y la moda para la posterior Beta
valor_esperado <- a_post / (a_post + b_post)

if (a_post > 1 && b_post > 1) {
  moda <- (a_post - 1) / (a_post + b_post - 2)
} else {
  moda <- NA  # La moda no se encuentra en valores centrales si a_post o b_post <= 1
}

# Mostrar resultados
cat("Valor esperado (media):", valor_esperado, "\n")
cat("Moda:", ifelse(!is.na(moda), moda, "No definida debido a a_post <= 1 o b_post <= 1"), "\n")

```

:::

## Ajuste con una nueva muestra

-   El director de investigaci√≥n de mercado no est√° totalmente seguro con los resultados, y pide a su departamento recoger una nueva muestra, mayor, para el estudio. Te dan acceso a los siguientes datos de la nueva muestra:

```{r beta-binomial-muestra2}
aceptacion_muestra_2 <- tibble(
  id_participante   = 1:113,
  resp_descarga_app = c(
    "Si", "Si", "No", "No", "Si", "Si", "Si", "Si", "No", "Si", "Si",
    "Si", "Si", "Si", "Si", "Si", "No", "Si", "No", "Si", "Si", "Si", 
    "No", "Si", "Si", "Si", "Si", "No", "No", "Si", "No", "Si", "Si", 
    "Si", "Si", "Si", "No", "Si", "No", "No", "Si", "No", "Si", "Si", 
    "No", "No", "No", "Si", "No", "No", "Si", "Si", "No", "No", "Si", 
    "No", "Si", "No", "No", "No", "Si", "Si", "No", "Si", "Si", "No", 
    "Si", "Si", "No", "Si", "Si", "No", "Si", "No", "Si", "No", "Si", 
    "No", "No", "No", "Si", "Si", "No", "No", "Si", "Si", "No", "No", 
    "No", "Si", "Si", "No", "Si", "Si", "No", "Si", "Si", "Si", "Si", 
    "No", "Si", "No", "No", "No", "No", "No", "Si", "No", "No", "Si", 
    "Si", "Si", "Si"
  )
)
```

### Pregunta 18

-   ¬øQu√© distribuci√≥n previa utilizar√≠as en esta ocasi√≥n? Form√∫lala.

::: {#respuesta-18 .callout-note}
Utilizar√≠a la distribuci√≥n posterior obtenida con la primera muestra de participantes 

$\text{Beta}(a_{\text{post}}, b_{\text{post}})$
:::

### Pregunta 19

-   Obt√©n la distribuci√≥n posterior anal√≠tica despu√©s de esta segunda muestra, repres√©ntala junto con las dos distribuciones anteriores, y obt√©n los estimadores posteriores esperado y modal.

::: {#respuesta-19 .callout-note}
```{r distribuci√≥n posterior muestra 2}
# Calcular n y y para la nueva muestra
n2 <- nrow(aceptacion_muestra_2)
y2 <- sum(aceptacion_muestra_2$resp_descarga_app == "Si")

# Prior Beta(1, 1)
a_prior <- 1
b_prior <- 1

# Posterior tras la primera muestra
n1 <- 22
y1 <- 17
a_post_1 <- a_prior + y1
b_post_1 <- b_prior + (n1 - y1)

# Posterior tras la segunda muestra
a_post_2 <- a_prior + y2
b_post_2 <- b_prior + (n2 - y2)

# Crear secuencia de probabilidades
p <- seq(0, 1, length.out = 1000)

# Calcular densidades de las distribuciones
densidad_prior <- dbeta(p, a_prior, b_prior)
densidad_post_1 <- dbeta(p, a_post_1, b_post_1)
densidad_post_2 <- dbeta(p, a_post_2, b_post_2)
# Crear tibble para graficar
data <- tibble(
  p = c(p, p, p),  # Concatenamos los valores de p tres veces
  densidad = c(densidad_prior, densidad_post_1, densidad_post_2),  # Concatenamos las densidades
  tipo = factor(c(
    rep("Prior", length(densidad_prior)),
    rep("Posterior 1", length(densidad_post_1)),
    rep("Posterior 2", length(densidad_post_2))
  ))  # Etiquetas ajustadas al tama√±o exacto de las densidades
)

# Graficar las distribuciones
ggplot(data, aes(x = p, y = densidad, color = tipo)) +
  geom_line(size = 1) +
  labs(title = "Comparaci√≥n de distribuciones Beta",
       x = "Tasa de aceptaci√≥n (p)",
       y = "Densidad de probabilidad") +
  theme_minimal() +
  scale_color_manual(values = c("red", "blue", "green"))

# Calcular el valor esperado y la moda de la posterior tras la segunda muestra
valor_esperado_2 <- a_post_2 / (a_post_2 + b_post_2)
moda_2 <- if (a_post_2 > 1 && b_post_2 > 1) {
  (a_post_2 - 1) / (a_post_2 + b_post_2 - 2)
} else {
  NA
}
# Mostrar resultados
cat("Valor esperado posterior (segunda muestra):", valor_esperado_2, "\n")
cat("Moda posterior (segunda muestra):", ifelse(!is.na(moda_2), moda_2, "No definida debido a par√°metros insuficientes"), "\n")

```

:::

## Ajuste con las muestras colapsadas

Sup√≥n que el director de investigaci√≥n de mercado no estaba contento con la muestra inicial y pidi√≥ recoger m√°s muestra antes de darte acceso a los datos.
Cuando recibes los datos, recibes las dos muestras colapsadas, sin saber qu√© participantes eran de la primera o de la segunda muestra:

```{r beta-binomial-muestra-total}
aceptacion_muestra_total <- bind_rows(
  aceptacion_muestra, aceptacion_muestra_2
) |>
  mutate(id_participante = row_number()) # Los ID est√°n colapsados en una serie
```

### Pregunta 20

-   Obt√©n la distribuci√≥n posterior anal√≠tica despu√©s de esta segunda muestra, repres√©ntala junto con las distribuciones anteriores, y obt√©n los estimadores posteriores esperado y modal.

::: {#respuesta-20 .callout-note}
```{r distribuci√≥n poserior muestra total}
# Datos consolidados
aceptacion_muestra_total <- bind_rows(
  aceptacion_muestra, aceptacion_muestra_2
) |>
  mutate(id_participante = row_number())

# Calcular tama√±o total de la muestra y √©xitos
n <- nrow(aceptacion_muestra_total)
y <- sum(aceptacion_muestra_total$resp_descarga_app == "Si")

# Prior Beta(1, 1)
a_prior <- 1
b_prior <- 1

# Posterior despu√©s de la primera muestra
n1 <- 22
y1 <- 17
a_post_1 <- a_prior + y1
b_post_1 <- b_prior + (n1 - y1)

# Posterior despu√©s de la muestra total
a_post_2 <- a_prior + y
b_post_2 <- b_prior + (n - y)
# Crear secuencia de probabilidades
p <- seq(0, 1, length.out = 1000)

# Calcular densidades
densidad_prior <- dbeta(p, a_prior, b_prior)
densidad_post_1 <- dbeta(p, a_post_1, b_post_1)
densidad_post_2 <- dbeta(p, a_post_2, b_post_2)
# Crear tibble para graficar
data <- tibble(
  p = c(p, p, p),  # Concatenamos los valores de p tres veces
  densidad = c(densidad_prior, densidad_post_1, densidad_post_2),  # Concatenamos las densidades
  tipo = factor(c(
    rep("Prior", length(densidad_prior)),
    rep("Posterior 1", length(densidad_post_1)),
    rep("Posterior 2", length(densidad_post_2))
  ))  # Etiquetas ajustadas al tama√±o exacto de las densidades
)

# Graficar distribuciones
ggplot(data, aes(x = p, y = densidad, color = tipo)) +
  geom_line(size = 1) +
  labs(title = "Distribuciones Beta: Prior, Posterior 1 y Posterior 2",
       x = "Tasa de aceptaci√≥n (p)",
       y = "Densidad de probabilidad") +
  theme_minimal() +
  scale_color_manual(values = c("red", "blue", "green"))
# Calcular valor esperado y moda para la posterior final
valor_esperado <- a_post_2 / (a_post_2 + b_post_2)
moda <- if (a_post_2 > 1 && b_post_2 > 1) {
  (a_post_2 - 1) / (a_post_2 + b_post_2 - 2)
} else {
  NA
}

# Mostrar resultados
cat("Valor esperado posterior combinado:", valor_esperado, "\n")
cat("Moda posterior combinada:", ifelse(!is.na(moda), moda, "No definida debido a par√°metros insuficientes"), "\n")

```

:::

### Pregunta 21

-   ¬øQu√© concluyes de la respuesta anterior? ¬øEn qu√© se diferencia este enfoque del an√°lisis de datos cl√°sico o frecuentista?

::: {#respuesta-21 .callout-note}
En funci√≥n de la informaci√≥n previa de que diponemos los resultados var√≠an ligeramente. la densidad de probabilidad de la distribuci√≥n posterior 2 aumenta. As√≠ mismo tambi√©n aumenta ligeramente el valor esperado posterior y la moda posterior. La principal diferencia respecto alenfoque frecuentista es que el enfoque bayesiano utiliza las informaciones previas a la vez que los datos observados. De este modo supne un enfoque algo m√°s din√°mico pues las actualizaciones de los datos observados se hacen en base a los datos obtenidos previamente. El enfoque frecuentoista ser√≠a algo m√°s est√°tico, pues se centra en estimar los datos para una muestra determinada.
:::

# Ejercicio 4

*(NOTA: Para todas las distribuciones, utiliza el valor de `PREC` definido en el ejercicio 1.)*

En un proyecto de investigaci√≥n educativo, el equipo investigador ha evaluado la rapidez de lectura en las dos clases de 1¬∫ de ESO de un colegio.
Los datos que te entregan consisten en el tiempo en segundos que tarda cada ni√±o en leer un texto estandarizado.

Se quiere obtener un par√°metro global promedio del tiempo de lectura para el alumnado de 1¬∫ de ESO en el colegio, para lo que te piden ajustar un modelo normal-normal.
Se pide usar como distribuci√≥n previa la estimada de la poblaci√≥n, que tiene media y varianza de 247 y 1156, respectivamente.

Los datos que te han facilitado son:

```{r normal-normal-muestras}
clase_1 <- tibble(
  id     = 1:27,
  tiempo = c(
    242, 249, 278, 273, 227, 257, 276, 236, 214, 141, 200, 201, 
    228, 271, 160, 275, 156, 246, 293, 306, 263, 247, 224, 160, 277, 
    168, 250
  )
)

clase_2 <- tibble(
  id     = 1:24,
  tiempo = c(
    195, 176, 237, 258, 226, 254, 292, 212, 215, 298, 235, 244, 
    144, 227, 166, 194, 261, 187, 224, 233, 180, 167, 193, 282
  )
)
```

## Modelo normal-normal

### Pregunta 22

-   Determina la verosimilitud y las distribuciones previa y posterior de la media, asumiendo que la varianza de la verosimilitud es la varianza de los datos. Justifica c√≥mo has obtenido los par√°metros de la distribuci√≥n posterior (usa 2 decimales de precisi√≥n).

::: {#respuesta-22 .callout-note}
:::

## Estimaci√≥n

### Pregunta 23

-   Representa las distribuciones previa y posterior de la media; considera un eje que cubra 4 desviaciones t√≠picas a cada lado de la media de la distribuci√≥n previa. Obten el estimador esperado y modal a partir de esta distribuci√≥n y comp√°ralos con la soluci√≥n anal√≠tica de la pregunta anterior.

::: {#respuesta-23 .callout-note}
:::
